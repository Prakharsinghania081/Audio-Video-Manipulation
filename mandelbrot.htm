<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8"/>
	<title>Canvas</title>
	
	<style type="text/css">
html,body {
	margin:0;padding:0;
	background:black;
	font-family:"Times New Roman", Times, serif;
	font-size:14px;
	overflow:hidden;
}

#mandelbrot {
	position:absolute;
	background:green;
	display:block;
	z-index:1;
}

.zoom {
	display:none;
	position:absolute;
	z-index:2;
	cursor:crosshair;
}

.history {
	width:200px;height:40px;
	overflow:hidden!important;
	
	position:absolute;z-index:5;
	overflow:auto;
	
	background:#333;
	color:white;
	
	margin-top:0;padding-right:20px;
}

.history:hover {
	height:100%;
	overflow:auto!important;
}

.history p {
	text-align:center;
	font-size:20px;
	margin:10px 0px;
	position:fixed;
	width:inherit;
}

.history ol {margin-top:0px}
.history li {cursor:pointer;padding:5px;}
.history li:first-child {margin-top:45px}
.history li:hover {background:#777;}
.history li.selected {outline:1px orange solid;}

	</style>
	
	<script>

function _gel(x) {return document.getElementById(x)}

function Mandelbrot(canvasId) {

// Private

	var that = this;
	
	// initialization
	var canvas = _gel(canvasId);
	var c = canvas.getContext("2d");
	var style = canvas.style;
	
	// zooming
	var zcanvas = document.createElement('canvas');
	zcanvas.className = 'zoom';
	canvas.parentNode.appendChild(zcanvas);
	var magnification = 1;
	var magnifyBy = 4;
	var zoomFlag = true;
	
	// current bounds
	var xmin = -2.0, xmax = 0.5;
	var ymin = -1.0, ymax = 1.0;
	
	// history
	var history = document.createElement('div');
	history.className = 'history';
	history.innerHTML = '<p>History</p><ol></ol>';
	canvas.parentNode.appendChild(history);
	history = history.getElementsByTagName('ol')[0];
	history.prev = 0;
	
	var maxIter = 40;
	var maxIterBound = 1000;
	
	// ratio is 5:4, or 1.25
	var ratio = (xmax-xmin) / (ymax-ymin);

	var buffer = [];
	
	function setArea(x1, x2, y1, y2) {
		xmin = x1;
		xmax = x2;
		ymin = y1;
		ymax = y2;
		
		// we know that ratio will remain the same
		// since the zoom canvas is a copy of the mandelbrot one
	}
	
	// map (x1,y1), (x2,y2) to positions on the complex plane
	// i.e., find values of xmin, xmax, ymin, ymax
	// (then generate and draw)
	function zoom(x1, y1, x2, y2) {
	
		x1 = xmin + x1 * (xmax-xmin) / parseInt(style.width);
		x2 = xmin + x2 * (xmax-xmin) / parseInt(style.width);
		
		y1 = ymax - y1 * (ymax-ymin) / parseInt(style.height);
		y2 = ymax - y2 * (ymax-ymin) / parseInt(style.height);
		
		setArea(x1, x2, y2, y1);
		
		that.generate();
		that.draw();
	}
	
	function setupZoom() {
		if(!zoomFlag) return; // is this really needed?
		
		var zstyle = zcanvas.style;
		var context = zcanvas.getContext('2d');
		
		// update current magnification
		magnification *= magnifyBy;
		
		// set zoom canvas to same size and position as mandelbrot
		zcanvas.width = parseInt(style.width);
		zcanvas.height = parseInt(style.height);
		zstyle.display = 'block';
		zstyle.width = style.width;
		zstyle.height = style.height;
		zstyle.left = style.left;
		zstyle.top = style.top;
		
		// zoom box colour
		context.fillStyle = "rgba(255, 255, 255, 0.5)";
	
		// setup some values to help position the zoom box
		var offset = {
			x: zstyle.left? parseInt(zstyle.left):0,
			y: zstyle.top? parseInt(zstyle.top):0
		};
	
		var box = {
			width: Math.floor(parseInt(zstyle.width)/magnifyBy),
			height: Math.floor(parseInt(zstyle.height)/magnifyBy),
		};
		box.xMin = Math.floor(box.width/2);
		box.xMax = zcanvas.width - box.xMin;
		box.yMin = Math.floor(box.height/2);
		box.yMax = zcanvas.height - box.yMin;
		
		zcanvas.onclick = zcanvas.onmousemove = function (mouse) {
			// get relative mouse position
			// a general method is available at 
			// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
			var x = (mouse.clientX - offset.x);
			var y = (mouse.clientY - offset.y);
		
			// setup box position
			// x,y is in the middle of the box: need to move to top left.
			if( x < box.xMin )
				x = box.xMin;
			else if( x > box.xMax )
				x = box.xMax;
		
			x -= box.xMin;
		
			if( y < box.yMin )
				y = box.yMin;
			else if( y > box.yMax )
				y = box.yMax;
		
			y -= box.yMin;
		
			// draw box
			if( mouse.type == 'click' ) {
				zoom(x, y, x+box.width, y+box.height);
			}
			else {
				context.clearRect(0, 0, zcanvas.width, zcanvas.height);
				context.fillRect(x, y, box.width, box.height);
			}
		}
	
		zcanvas.onmouseout = function() {
			zcanvas.getContext('2d').clearRect(0, 0, zcanvas.width, zcanvas.height);
		}
		/**/
		zoomFlag = false;
	}

// Privileged
// need to make these callers to public functions

	this.getCanvas = function () {
		return canvas;
	}

	this.setCanvasResolution = function (width, height) {
		if( width / height < ratio ) {
			canvas.height = Math.floor(width / ratio);
			canvas.width = width;
		}
		else {
			canvas.height = height;
			canvas.width = Math.floor(height * ratio);
		}
		style.width = canvas.width + 'px';
		style.height = canvas.height + 'px';
		zoomFlag = true;
		setupZoom();
	}
	
	this.fitCanvasToScreen = function () {
		var width = window.innerWidth || document.documentElement.clientWidth;
		var height = window.innerHeight || document.documentElement.clientHeight;
		
		if( width / height < ratio ) {
			style.width = width + 'px';
			style.height = Math.floor(width / ratio) + 'px';
			style.top = Math.floor( ( height - parseInt(style.height) ) / 2 ) + 'px';
		}
		else {
			style.width = Math.floor(height * ratio) + 'px';
			style.height = height + 'px';
			style.left = Math.floor( ( width - parseInt(style.width) ) / 2 ) + 'px';
		}
		zoomFlag = true;
		setupZoom();
	}
	
	this.setMaxIter = function (iter) {
		maxIter = ( iter < maxIterBound ) ? iter : maxIterBound;
	}
	
	this.generate = function() {
		var width = canvas.width;
		var height = canvas.height;
		
		var xPixel, yPixel;
		var xScale = (xmax-xmin)/width, yScale = (ymax-ymin)/height; // should these be -1 ??
		
		var x0, y0; // c is (x0,y0)
		var x, y; // z is (x,y)
		var temp;
		
		var colour;
		var max = -Infinity , min = Infinity ; // for normalizing colour values
		
		var bufSize = width*height;
		var i; // #iterations per c(x0,y0)
		
		for(i=0; i<bufSize; i++) buffer[i] = 0.0;
	
		for(yPixel=0; yPixel<height; yPixel++) {
			for(xPixel=0; xPixel<width; xPixel++) {
				
				// x0 and y0 are scaled x and y coordinates of (xPixel, yPixel)
				// TODO: optimize
				x0 = xmin + xScale*xPixel;
				y0 = ymax - yScale*yPixel;
				
				x = y = 0.0; // could skip first iteration by setting to x0,y0
				
				// do up to maxIter iterations
				// TODO: optimize
				
				for(i=0; (x*x + y*y < 4) && (i < maxIter); i++) {
					temp = x*x - y*y + x0;
					y = 2.0*x*y + y0;
					x = temp;
				}
				
				// assign buffer value for (xPixel, yPixel)
				if( i < maxIter ) {
					colour = i - Math.log(0.5*Math.log(x*x + y*y)/Math.LN2)/Math.LN2; // 0.25??
					if( colour < min ) min = colour;
					if( colour > max ) max = colour;
					buffer[yPixel*width + xPixel] = colour;
				}
				else
					buffer[yPixel*width + xPixel] = 0.0;
			}
		}
		
		// normalize buffer values
		max -= min;
		if( min > 0.0 ) {
			// there might be 0.0 values in the buffer
			for( i=0; i<bufSize; i++ )
				if( buffer[i] > 0.0 )
					buffer[i] = (buffer[i] - min) / max;
		}
		else {
			// this shouldn't happen
			for( i=0; i<bufSize; i++ )
				buffer[i] = (buffer[i] - min) / max;
		}
	}
	
	this.draw = function () {
		var v;
		var offset;
		var x, y;
		
		for(y=0; y<canvas.height; y++) {
			for(x=0; x<canvas.width; x++) {
			
				v = Math.floor(buffer[y*canvas.width+ x] * 768);
				// skipping checks: relying on buffer being normalized
				// if( v < 0 ) v = 0;
				// else if( v > 768 ) v = 768;
				
				offset = v&255; // v%256
				
				/** /
				if (v<256)
					c.fillStyle = "rgb(0,0," + offset + ")";
				else if (v<512)
					c.fillStyle = "rgb(0," + offset + "," + (255-offset) + ")";
				else
					c.fillStyle = "rgb(" + offset + "," + (255-offset) + ",0)";
				/**/
				
				if (v<256)
					c.fillStyle = "rgb(0,0," + offset + ")";
				else if (v<512)
					c.fillStyle = "rgb(0," + offset + "," + 0 + ")";
				else
					c.fillStyle = "rgb(" + offset + "," + offset + ",0)";
				
				c.fillRect(x,y,1,1);
			}
		}
		
		setupZoom(); // is this needed? Only if setCanvasResolution & fitCanvasToScreen are never called
		
		// create history
		var line = document.createElement('li');
		line.area = [xmin,xmax,ymin,ymax];
		line.image = new Image();
		line.image.src = canvas.toDataURL('image/png');
		
		line.onclick = function () {
			setArea.apply(that, this.area);
			c.drawImage(this.image, 0, 0);
			
			if( history.prev ) history.prev.className = '';
			line.className = 'selected';
			history.prev = line;
		}
		
		if( history.prev ) history.prev.className = '';
		line.className = 'selected';
		history.prev = line;
		
		var message = '';
		for(var i=0; i<line.area.length; i++)
			message += line.area[i].toPrecision(6) + ", ";
		history.appendChild(line).innerHTML = message.slice(0,-2);
	}
	/**/
}

// Mandelbrot: Public functions
Mandelbrot.prototype.replaceWithImage = function () {
	var c = this.getCanvas();
	var s = c.style;
		
	var img = document.createElement('img');
	img.src = c.toDataURL("image/png");
	
	img.style.width = s.width;
	img.style.height = s.height;
	img.style.top = s.top;
	img.style.left = s.left;
	img.style.position = 'absolute';
	img.style.zIndex = 3; // above the zoom canvas
	
	document.body.appendChild(img);
}

window.onload = function() {
	mandelbrot = new Mandelbrot('mandelbrot');
	
	// set parameters
	mandelbrot.setCanvasResolution(1000, 800);
	mandelbrot.setMaxIter(70);
	
	// drawing always fills the window
	mandelbrot.fitCanvasToScreen();
	window.onresize = function(){mandelbrot.fitCanvasToScreen();};
	
	// build and display the set
	mandelbrot.generate();
	mandelbrot.draw();
	
	// save as PNG
	//mandelbrot.replaceWithImage();
	
	// animation
	/*
	k=0;
	for( i=10; i<140; i+=10) {
		k++;
		setTimeout("mandelbrot.setMaxIter("+i+");mandelbrot.generate();mandelbrot.draw();", k*2000);
	}
	/**/
}

	</script>
</head>

<body>


<canvas id="mandelbrot"></canvas>
</body>

</html>

<!-- Debayan Gupta -->
